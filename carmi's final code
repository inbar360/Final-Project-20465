#include <stdio.h>
#define BITS 12
#typedef struct Data_Table{
    int value, length;
    char type;
    char[32] data;
    char binary[1024][BITS];
    Data_Table next;
}Data_Table;

#typedef struct Ent_Table{
    int value;
    char[32] data;
    Data_Table next;
}Ent_Table;

#typedef struct Ext_Table{
    int value;
    char[32] data;
    Data_Table next;
}Ext_Table;

Data_Table data_head;
Ent_Table ent_head;
Ext_Table ext_head;
int IC = 0, DC = 0, counter = 0, ERRORS = 0;

int is_label(file, line){
    int i = 0;
    while(i < 32 && *(st + i) != '\0' && *(st + i) != ':' && *(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n'){
        if((*(st + i) > 57 && *(st + i) < 65) || *(st + i) < 48 || (*(st + i) > 90 && *(st + i) < 97) || *(st + i) > 122)
            return 0;
        i++;
    }
    if(*(st + i) == ':') return 1;
}

int in_list(Data_Table dt, char[] str){
    dt1= dt;
    while(dt1 != NULL){
        if(strcmp(str, dt1.data) == 0){
            return 1;
        }
        dt1 = dt1.next;
    }
    return 0;
}

char[] opcode_in_binary(char* op){
  if(strncmp(op, "mov", 3) == 0)
    return "0000";
  if(strncmp(op, "cmp", 3) == 0)
    return "0001";
  if(strncmp(op, "add", 3) == 0)
    return "0010";
  if(strncmp(op, "sub", 3) == 0)
    return "0011";
  if(strncmp(op, "not", 3) == 0)
    return "0100";
  if(strncmp(op, "clr", 3) == 0)
    return "0101";
  if(strncmp(op, "lea", 3) == 0)
    return "0110";
  if(strncmp(op, "inc", 3) == 0)
    return "0111";
  if(strncmp(op, "dec", 3) == 0)
    return "1000";
  if(strncmp(op, "jmp", 3) == 0)
    return "1001";
  if(strncmp(op, "bne", 3) == 0)
    return "1010";
  if(strncmp(op, "red", 3) == 0)
    return "1011";
  if(strncmp(op, "prn", 3) == 0)
    return "1100";
  if(strncmp(op, "jsr", 3) == 0)
    return "1101";
  if(strncmp(op, "rts", 3) == 0)
    return "1110";
  if(strncmp(op, "stop", 4) == 0)
    return "1111";
  return NULL;
}

void make_binary(int n, int line, char* bits) {
    if(n > 2047 || n < -2048){
        n > 2047 ? printf("Error int line %d: integer to large | maximum size is 2047", line) : printf("Error int line %d: integer to small | minimum size is -2048", line);
        ERRORS++; 
        return;
    }
    int abs_n = (n < 0) ? -n : n;//make negative positive
    
    char bin[BITS]; 
    int i = BITS - 1;
    while(i >= 0) {
        bin[i] = (abs_n % 2) + '0';
        abs_n /= 2;
        i--;
    }
    
    
    if (n < 0) {
      
        for (int j = 0; j < BITS; j++) {// Invert the bits
            bin[j] = (bin[j] == '0') ? '1' : '0';
        }
        
        
        int carry = 1;// Add 1 to the result
        for (int j = BITS - 1; j >= 0; j--) {
            if (bin[j] == '0' && carry == 1) {
                bin[j] = '1';
                carry = 0;
            } else if (bin[j] == '1' && carry == 1) {
                bin[j] = '0';
            }
        }
    }
    
    for(int j = 0; j < 12; j++){
        *(bits + j) = bin[j];
    }
}


char[] organization_type(op){
    int 0;
    if(op[0] == '@' && op[1] = 'r' && op[2] <= '7' && op[2] >= '0' && (op[3] == '\n' || op[3] == '\t' || op[3] == ' ')){
        return "101";
    }
    int is_num = 0;
    while(op[i] != '\n' && op[i] != '\t' && op[i] != ' '){
        if(op[i] < '0' || op[1] > '9')
            is_num = 1;
    }
    if(is_num = 0)
        return "001"
    int is_label = 0, i = 0;
    while(op[i] != '\n' && op[i] != '\t' && op[i] != ' '){
        if(op[i] > 57 && op[i] < 65) || op[i] < 48 || (op[i] > 90 && *(st + i) < 97) || op[i] > 122))
            flag = 1;
    }
    if(i > 32){
        printf("Error: non legal operand");
        ERRORS++;
        return NULL;
    }
    if(flag == 1){
        printf("Error: non legal operand");
        ERRORS++;
    }
    return "011"
}

char[] make_command_binary(text of line st){
    char binary[12], command[4] , fir_op[3] = "000", sec_op[3] = "000", ARE[] = "00";
    int i = 0;
    SKIP_WHITE(st, i);
    if(st[i] != '.'){
        SKIP_NON_WHITE(st, i);
        SKIP_WHITE(st, i);
        command = opcode_in_binary(st + i * sizeof(char));
    }
    else
        command = opcode_in_binary(st + i * sizeof(char));
    SKIP_NON_WHITE(st, i);
    if(st[i] != '\n')
        fir_op = organization_type(st + i * sizeof(char));
    SKIP_NON_WHITE(st, i);
    if(st[i] != '\n')
        sec_op = organization_type(st + i * sizeof(char));
    int j = 0;
    for(;j < 3; j++){
        binary[j] = fir_op[j];
    }
    for(;j < 7; j++){
        binary[j] = command[j];
    }
    for(; j < 10; j++){
        binary[j] = sec_op[j];
    }
    for(; j < 12; j++){
        binary[j] = ARE[j];
    }
    return binary;
}

int make_memory_of_command_label(file string st){
    int errors_here = 0, length = 0;
    Data_Table* curr = &date_head;
    for(i = 0; i < counter; i++){ //going to the next empty node
        curr = &(curr->next);
    }
    char lab[] = char[32];
    int i = 0;
    SKIP_WHITE(st, i);
    int white = i;
    while(i - white < 32 && *(st + i) != '\0' && *(st + i) != ':' && *(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n'){
        if((*(st + i) > 57 && *(st + i) < 65) || *(st + i) < 48 || (*(st + i) > 90 && *(st + i) < 97) || *(st + i) > 122)
            return 1; //means its not a label
        lab[i] = *(st + i);
        i++;
    }
    if(*(st + i) == ':'){
        if(*(st + (i + 1)) != ' ' || *(st + (i + 1)) != '\t'){
            printf("Error: no seperation bitween label and operands");
            errors_here++;
            ERRORS++;
            i++;
        }
        else
            i += 2;
        SKIP_WHITE(st, i);
        if(opcode_in_binary(st + i) == NULL){
            return 2;//means the label is not for command
        }
        length++;
        if(strcmp(opcode_in_binary(st + i), "1111") == 0)
            i += 4;
        else
            i += 3;
        if(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n'){
            printf("Error: no seperation bitween label and operands");
            errors_here++;
            ERRORS++;
        }
        SKIP_WHITE(st, i);
        if(*(st + i) != '\n'){
            length++;
        while(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n')
            i++;
        SKIP_WHITE(st, i);
        if(*(st + i) != '\n'){
            length++;
        while(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n')
            i++;
        SKIP_WHITE(st, i);
        if(*(st + i) != '\n'){{
            printf("Error: to many operands");
            errors_here++;
            ERRORS++;
        }
        Data_Table new;
        if(!new){
            printf("Error: could not allocate mamory for data")
            errors_here++;
            ERRORS++;
        }
        if(errors_here > 0){
            return 0;
        }
        new.data = lab;
        new.type = 'C';//diferent from comand with label
        new.length = length;
        if(counter == 0){
            new.value = 100;
            data_head = new_data;
        }
        else{
            new.value = 100 + IC ;
            curr->next = new_data;
        }
        IC += length;
        counter++;
        return 3; //done succesfully
    }

}

int make_memory_of_command(file string st){
    int errors_here = 0, length = 0;
    Data_Table* curr = &date_head;
    for(i = 0; i < counter; i++){ //going to the next empty node
        curr = &(curr->next);
    }
    int i = 0;
    SKIP_WHITE(st, i);
    if(opcode_in_binary(st + sizeof(char) * i) == NULL){
        return 2;//means this is not for command
    }
    length++;
    if(strcmp(opcode_in_binary(st + i), "1111") == 0)
        i += 5;
    else
        i += 4;
    if(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n'){
        printf("Error: no seperation bitween label and operands");
        errors_here++;
        ERRORS++;
    }
    SKIP_WHITE(st, i);
    if(*(st + i) != '\n'){
        length++;
        while(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n')
            i++;
        SKIP_WHITE(st, i);
        if(*(st + i) != '\n'){
            length++;
            while(*(st + i) != ' ' || *(st + i) != '\t' || *(st + i) != '\n')
                i++;
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){
                printf("Error: to many operands");
                errors_here++;
                ERRORS++;
            }
        }
    }
    Data_Table new;
    if(!new){
        printf("Error: could not allocate mamory for data")
        errors_here++;
        ERRORS++;
    }
    if(errors_here > 0){
        return 0;
    }
    new.type = 'c';
    new.length = length;
    if(counter == 0){
        new.value = 100;
        data_head = new_data;
    }
    else{
        new.value = 100 + IC ;
        curr->next = new_data;
    }
    IC += length;
    counter++;
    return 3; //done succesfully
    }

}

int add_extern_data(file string st, int line){
    int i = 0, errors_here = 0, data_count = 0, DC_here = DC;
    Data_Table data[1024];
    Data_Table* curr = &date_head;
    for(i = 0; i < counter; i++){ //going to the next empty node
        curr = &(curr->next);
    }
    i = SKIP_WHITE(st, i);
    if(is_label(st + sizeof(char) + i)) == 1){
        while(*(st + i) != ':')
            i++;
    }
    if(*(st + ++i) != ' ' && *(st + i) != '\t'){
        printf("Error in line %d: no seperation bitween label and command", line);
        ERRORS++;
        errors_here++;
    }
    else
        i = SKIP_WHITE(st,i);
    if(strncmp(st + sizeof(char) * i, ".extern", 7) == 0){
        i += 7;
        if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
            printf("Error in line %d: no seperation bitween command and operands", line);
            ERRORS++;
            errors_here++;
        }
        else
            i = SKIP_WHITE(st, i);
        while(st[i] != '\n'){
            int l = i;
            while(st[l] != ' ' && st[l] != '\t' && st[l] != '\n')
                l++;
            int j = 0, in_list = 0;
            Data_Table temp = data_head;
            while(j < counter && in_list = 0){
                if(strncmp(temp.data, st + sizeof(char) * i, l - i) == 0 && strlen(temp.data) == l - i){
                    in_list = 1;
                    printf("Error in line %d: declared an existing internal label external", line);
                    ERRORS++;
                    errors_here++;
                }
                j++;
            }
            int legal = 1;
            if(l - i > 32){
                printf("Error in line %d: label length longer than maximum of 32 letter", line);
                ERRORS++;
                errors_here++;
                legal = 0;
            }
            for(int m = i; m < l; m++){
                if((*(st + (i + m)) > 57 && *(st + (i + m)) < 65) || *(st + (i + m)) < 48 || (*(st + (i + m)) > 90 && *(st + (i + m)) < 97) || *(st + (i + m)) > 122){
                    printf("Error in line %d: non alphanumeric charachters in label", line);
                    ERRORS++;
                    errors_here++;
                    legal = 0;
                    break;
                }
            }
            Data_Table new_data;
            if(legal == 1){
                for(int m = i; m < l; m++)
                    new_data.data[m] = *(st + (i + m));
            }
            i = l;
            i = SKIP_WHITE(st, i);
            if(errors_here > 0)
                return 0;
            new_data.type = 'x';
            new_data.length = 1;
            new_data.value = 100 + DC_here++;
            data[data_count] = new_data;
            data_count++;
        }
        for(int m = 0; m < data_count; m++){
            if(counter == 0){
                data_head = data[m];
                counter++;
            }
            else{
                curr->next = data[m];
                curr = &get_next(*curr);
                counter++;
            }
        }
        DC = DC_here;
        return 1;
    }
    else
        return 2;
}

int mark_label_entry(file string st, int line){
    int i = 0, errors_here = 0;
    i = SKIP_WHITE(st, i);
    if(is_label(st + sizeof(char) + i)) == 1){
        while(*(st + i) != ':')
            i++;
    }
    if(*(st + ++i) != ' ' && *(st + i) != '\t'){
        printf("Error in line %d: no seperation bitween label and command", line);
        ERRORS++;
        errors_here++;
    }
    else
        i = SKIP_WHITE(st,i);
    if(strncmp(st + sizeof(char) * i, ".entry", 6) == 0){
        i += 6;
        if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
            printf("Error in line %d: no seperation bitween command and operands", line);
            ERRORS++;
            errors_here++;
        }
        else
            i = SKIP_WHITE(st, i);
        while(st[i] != '\n'){
            int l = i;
            while(st[l] != ' ' && st[l] != '\t' && st[l] != '\n')
                l++;
            int j = 0, in_list = 0;
            Data_Table temp = data_head;
            while(j < counter && in_list == 0){
                if(strncmp(temp.data, st + sizeof(char) * i, l - i) == 0 && strlen(temp.data) == l - i)
                    in_list = 1;
                temp = get_next(temp);
                j++;
            }
            Data_Table* curr = &date_head;
            for(i = 0; i < j; i++){ //going to the next empty node
                curr = &(curr->next);
            }
            if(curr->type == "x"){
                printf("Error in line %d: tried to declare an external label an entry");
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr->type = 'e';
            i = l;
            i = SKIP_WHITE(st, i);
        }
        return 1;
    }

}

int add_string_data(file string st, int line){//adds labels of .string type
    Data_Table* curr = &date_head;
    for(i = 0; i < counter; i++){ //going to the next empty node
        curr = &(curr->next);
    }

    char[] lab = char[32];
    int i = 0;
    SKIP_WHITE(st, i);
    int white = i;
    while(i - white < 32 && *(st + i) != '\0' && *(st + i) != ':' && *(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n'){
        if((*(st + i) > 57 && *(st + i) < 65) || *(st + i) < 48 || (*(st + i) > 90 && *(st + i) < 97) || *(st + i) > 122)
            return 1; //means its not a label
        lab[i - white] = *(st + i);
        i++;
    }
    if(*(st + i) == ':'){
        int errors_here = 0;
        int start, end, length = 0;
        char* string = (char*) malloc(sizeof(char));
        if(*(st + (i + 1)) != ' ' || *(st + (i + 1)) != '\t'){
            printf("Error: no seperation bitween label and operands");
            errors_here++;
            ERRORS++;
            i++;
        }
        else
            i += 2;
        SKIP_WHITE(st, i);
        if(strncmp(st+i, ".string", 7) == 0){
            i += 7;
            if(*(st + i) != '\t' && *(st + i) != ' '){
                printf("///Error in line %d: no seperation bitween .string and the string///", line);
                errors_here++;
                ERRORS++;
            }
            SKIP_WHITE(st, i);
            if(*(st + i) != '"'){
                printf("///Error in line %d: no quotation marks in the beginning of the string///", line);
                errors_here++;
                ERRORS++;
            }
            start = ++i;
            while(*(st + i) != '"' && *(st + i) != '\n'){
                if(*(st + i) <= 31 || *(st + i) >= 128){
                    printf("///Error in line %d: non printable char in string///", line);
                    errors_here++;
                    ERRORS++;
                }
                *(string + length) = *(st + i);
                length++;
                i++;
            }
            if(*(st + i) == '\n'){
                printf("///Error in line %d: no quotation marks in the end of the string///", line);
                errors_here++;
                ERRORS++;
            }
            end = i++;
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){
                printf("///Error in line %d: to many operands in the declaration of .string///", line);
                errors_here++;
                ERRORS;
            }
            if(in_list(data_head, lab) == 1){
                printf("///Error in line %d: label - '%s' declared multiple times///", line, lab);
                errors_here++;
                ERRORS++;
            }
            Data_Table new;
            if(!new){
                printf("Error: could not allocate mamory for data")
                errors_here++;
                ERRORS++;
            }
            new.type = 'n';
            new.length = length + 1;//plus 1 is for the NULL terminator
            new.data = lab;
            new.next = NULL;
            if(!new.binary){
                printf("Error: could not allocate mamory for data")
                errors_here++;
                ERRORS++;
            }
            for(int k = 0; k < length; k++){
                char temp[12];
                make_binary(*(string + k), line, temp);
                for(int z = 0; z < 12; z++){
                     new.binary[k][z] = temp[z];
                }
            }
            for(int m = 0; m < 12; m++){
                new.binary[length][m] = '0';
            }
            if(errors_here > 0){
                return 0;//means that there were errors
            }
            if(counter == 0){
                new.value = 100;
                data_head = new_data;
            }
            else{
                new.value = 100 + DC;
                curr->next = new_data;
            }
            DC += length + 1;//plus 1 is for the NULL terminator
            counter++;//seccesfully added a data table node
            return 3;//means that it succesfully added the data
        }
        return 2;//means that the label is not for string

    }
    else if(i - white == 32){
        printf("///Error in line %d: label longer then the maximum length of 32///", line);
        return 0;
    }
    else{
        printf("///Error in line %d: no ':' in the declaration of the label", line);
        return 0;
    }
}


int add_data_data(file string s1, int line){//adds labels of .data type
    Data_Table* curr = &date_head;
    for(i = 0; i < counter; i++){ //going to the next empty node
        curr = &(curr->next);
    }
    int data_values[] = int[1024];
    int i = 0;
    char[] lab = char[32];
    SKIP_WHITE(st, i);
    int white = i;
    while(i - white < 32 && *(st + i) != '\0' && *(st + i) != ':' && *(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n'){
        if((*(st + i) > 57 && *(st + i) < 65) || *(st + i) < 48 || (*(st + i) > 90 && *(st + i) < 97) || *(st + i) > 122)
            return 1;         //printf("///Error in line %d: label name can only contain numbers and English letters (lower and upper case)///", line);
        lab[i - white] = *(st + i);
        i++;
    }
    if(*(st + i) == ':'){
        if(*(st + (i + 1)) != ' ' || *(st + (i + 1)) != '\t'){
            printf("Error: no seperation bitween label and operands");
            errors_here++;
            ERRORS++;
            i++;
        }
        else
            i += 2;
        SKIP_WHITE(st, i);
        if(strncmp(st + i, ".data", 5) == 0){
            i += 5;
            if(*(st + i) != '\t' && *(st + i) != ' '){
                printf("///Error in line %d: no seperation bitween ':' and .data///", line);
                errors_here++;
                ERRORS++;
            }
            SKIP_WHITE(st, i);
            int d_counter = 0;
            while(*(st + i) != '\n'){
                int minus = 0;
                if(*(st + i) == '-'){
                    i++
                    minus = 1;
                }
                int curr_num = 0, digits = 0;
                while(*(st + i) != ' ' && *(st + i) != ',' && *(st + i) != '\t'){
                    if(*(st + i) > 57 || *(st + i) < 48){
                        printf("///Error in line %d, character "d": operand is not of type int///", line, i);
                        errors_here++;
                        ERRORS++;
                        stop;
                    }
                    curr_num = curr_num * 10 + (*(st + i) - '0');
                    i++;
                }
                if(minus == 1)
                    data_values[d_counter] = curr_num * -1;
                else
                    data_values[d_counter] = curr_num;
                SKIP_WHITE(st, i);
                if(*(st + i) != ','){
                    printf("///Error in line %d: two operands not seperated by ','///", line);
                    errors_here++;
                    ERRORS++;
                }
                i++;
                SKIP_WHITE(st, i);
                d_counter++;
            }
            Data_Table new;
            if(!new){
                printf("Error: could not allocate mamory for data")
                errors_here++;
                ERRORS++;
            }
            new.type = 'n';
            new.length = d_counter;
            new.data = lab;
            new.next = NULL;
            if(!new.binary){
                printf("Error: could not allocate mamory for data")
                errors_here++;
                ERRORS++;
            }
            for(int k = 0; k < d_counter; k++){
                char temp[12];
                make_binary(data_values[k], line, temp);
                for(int z = 0; z < 12; z++){
                     new.binary[k][z] = temp[z];
                }
            }
            if(errors_here > 0){
                return 0;//means that there were errors
            }
            if(counter == 0){
                new.value = 100;
                data_head = new_data;
            }
            else{
                new.value = 100 + DC;
                curr->next = new_data;
            }
            DC += length;
            counter++;
            return 3;//success
        }
        return 2;//not for data

    }
    else if(i - white == 32){
        printf("///Error in line %d: label longer then the maximum length of 32///", line);
    }
    else{
        printf("///Error in line %d: no ':' in the declaration of the label", line);
    }
}


int is_value_command_legal_label(char* st, &Data_Table curr_node, int line){
    int i = 0, errors_here = 0;
        i = SKIP_WHITE(st, i);
        if(*(st + i) != '.'){
            int length = i;
            while(*(st + length) != ':' && length < 33 + i){
                length++;
            }
            if(st[length] != ':'){
                printf("Error in line %d: label to long", line);
                ERRORS++;
                errors_here++;
            }
            else
                i = ++length;
            if(st[i] != ' ' && st[i] != '\t' && st[i] != '\n'){
                printf("Error in line %d: no seperation bitween label and command", line);
                ERRORS++;
                errors_here++;
            }
            i = SKIP_WHITE(st, i);
        }
        
        if(*(st + i) != '.'){
            printf("Error in line %d: no function after label");
            ERRORS++;
            errors_here++;
        }
        else
            i++; //skip the '.' char before the function

        //no operand commands//
        if(strncmp(st + i, "stop", 4) == 0){
            i += 4;//go to the char after the command
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("///Error in line %d: operand found in an operand-less command", line);
                return 0;//wrong syntax
            }
            curr_node->binary[0] = make_command_binary(st);
            return 1;
        }

        else if(strncmp(st + i, "rts", 3) == 0){
            i += 3;//go to the char after the command
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("///Error in line %d: operand found in an operand-less command", line);
                return 0;//wrong syntax
            }
            curr_node->binary[0] = make_command_binary(st);
            return 1;
        }

        //one operand commands with 3 and 5 organization type operands//
        else if(strncmp(st + i, "not", 3) == 0 || strncmp(st + i, "clr", 3) == 0 || strncmp(st + i, "inc", 3) == 0 || strncmp(st + i, "dec", 3) == 0
        || strncmp(st + i, "jmp", 3) == 0 || strncmp(st + i, "bne", 3) == 0 || strncmp(st + i, "red", 3) == 0 || strncmp(st + i, "jsr", 3) == 0){ //3 and 5 
            char binary_word[12];
            i += 3;//go two chars after the command
            if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
                printf("Error in line %d: no seperation bitween comand and operands");
                ERRORS++;
                errors_here++;
            }
            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: no no operands in a single operand function");
                ERRORS++;
                return 0;
            }
            int l;
            if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                Data_Table temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                binary_word = temp_bin;
            }
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("Error in line %d: multiple operand in a single operand function");//wrong syntax
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr_node->binary[0] = make_command_binary(st);
            curr_node->binary[1] = binary_word;
            return 1;
        }

        //one operand commands with 1, 3 and 5 organization type operands//

        else if(strncmp(st + i, "prn", 3) == 0){
            char binary_word[12];
            i += 3;//go two chars after the command
            if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
                printf("Error in line %d: no seperation bitween comand and operands");
                ERRORS++;
                errors_here++;
            }
            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: no operands in a single operand function");
                ERRORS++;
                return 0;
            }

            int l = 0, m = 0, only_num = 1, neg = 0;
            while(*(st + (i + m)) != '\t' && *(st + (i + m)) != ' ' && *(st + (i + m)) != '\n'){
                if(*(st + i) == '-')
                    neg = 1;
                else if(*(st + (i + m)) < '0' || *(st + (i + m)) > '9')
                        only_num = 0;
                m++;
            }
            if(only_num == 1){
                int num = 0;
                for(int z = 0; z < m; z++){
                    if(neg == 1);
                    else
                        num = num * 10 + (*(st + (i + z)) - '0')
                }
                if(neg == 1)
                    num = -num;
                char temp_bin[12];
                make_binary(num, line, temp_bin);
                for(int z = 0; z < 12; z++){
                    if(z > 9)
                        temp_bin[z] = '0';
                    else
                        temp_bin[z] = temp_bin[z + 2];
                }
                binary_word = temp_bin;
            }
            else if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                Data_Table temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                binary_word = temp_bin;
            }
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("Error in line %d: multiple operand in a single operand function");//wrong syntax
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr_node->binary[0] = make_command_binary(st);
            curr_node->binary[1] = binary_word;
            return 1;
        }

        //two operand commands with 3 organization type first operand and 3 and 5 organization type second operand//

        else if(strncmp(st + i, "lea", 3) == 0){ 
            char first_binary_word[12], second_binary_word[12];
            i += 3;//go two chars after the command
            if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
                printf("Error in line %d: no seperation bitween command and operands");
                ERRORS++;
                errors_here++;
            }

            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: no operands in a two operand function");
                ERRORS++;
                return 0;
            }

            int l = 0;
            while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                l++;
            int in = 0, j = 0;
            Data_Table temp = data_head;
            while(j < counter && in != 1){
               if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                    in = 1;
                else{
                    temp = get_next(temp);
                    j++;
                }
            }
            if(in != 1){
                ERRORS++;
                errors_here++;
                printf("Error in line %d: reference to an undeclared label")
            }
            else{
                char temp_bin[12];
                make_binary(temp.value, line, temp_bin);
                for(int k = 0; k < 10; k++)
                    temp_bin[k] = temp_bin[k + 2];
                char ARE[] = temp.type == 'x' ? "01" : "10";
                for(int k = 10; k < 12; k++)
                    temp_bin[k] = ARE[k - 10];
                first_binary_word = temp_bin;
            }
            
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: only one operand in a two operand function");
                ERRORS++;
                return 0;
            }

            l = 0;
            if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                in = 0, j = 0;
                temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    second_binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                second_binary_word = temp_bin;
            }
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("Error in line %d: more then two operands in a two operand function");//wrong syntax
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr_node->binary[0] = make_command_binary(st);
            curr_node->binary[1] = first_binary_word;
            curr_node-binary[2] = second_binary_word;
            return 1;
        }

         //two operand commands with 1, 3 and 5 organization type first operand and 3 and 5 organization type second operand//

        else if(strncmp(st + i, "mov", 3) == 0 || strncmp(st + i, "add", 3) == 0 || strncmp(st + i, "sub", 3) == 0){ 
            char first_binary_word[12], second_binary_word[12];
            i += 3;//go two chars after the command
            if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
                printf("Error in line %d: no seperation bitween command and operands");
                ERRORS++;
                errors_here++;
            }

            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: no operands in a two operand function");
                ERRORS++;
                return 0;
            }

            int l = 0, m = 0, only_num = 1, neg = 0;
            while(*(st + (i + m)) != '\t' && *(st + (i + m)) != ' ' && *(st + (i + m)) != '\n'){
                if(*(st + i) == '-')
                    neg = 1;
                else if(*(st + (i + m)) < '0' || *(st + (i + m)) > '9')
                        only_num = 0;
                m++;
            }
            if(only_num == 1){
                int num = 0;
                for(int z = 0; z < m; z++){
                    if(neg == 1);
                    else
                        num = num * 10 + (*(st + (i + z)) - '0')
                }
                if(neg == 1)
                    num = -num;
                char temp_bin[12];
                make_binary(num, line, temp_bin);
                for(int z = 0; z < 12; z++){
                    if(z > 9)
                        temp_bin[z] = '0';
                    else
                        temp_bin[z] = temp_bin[z + 2];
                }
                first_binary_word = temp_bin;
            }
            else if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                Data_Table temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    first_binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                first_binary_word = temp_bin;
            }
            
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: only one operand in a two operand function");
                ERRORS++;
                return 0;
            }

            l = 0;
            if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    second_binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                second_binary_word = temp_bin;
            }
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("Error in line %d: more then two operands in a two operand function");//wrong syntax
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr_node->binary[0] = make_command_binary(st);
            curr_node->binary[1] = first_binary_word;
            curr_node-binary[2] = second_binary_word;
            return 1;
        }

         //two operand commands with 1, 3 and 5 organization type first operand and 1, 3 and 5 organization type second operand//

        else if(strncmp(st + i, "cmp", 3) == 0){ 
            char first_binary_word[12], second_binary_word[12];
            i += 3;//go two chars after the command
            if(*(st + i) != '\t' && *(st + i) != ' '){//check if there is a space aftre the command
                printf("Error in line %d: no seperation bitween command and operands");
                ERRORS++;
                errors_here++;
            }

            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: no operands in a two operand function");
                ERRORS++;
                return 0;
            }

            int l = 0, m = 0, only_num = 1, neg = 0;
            while(*(st + (i + m)) != '\t' && *(st + (i + m)) != ' ' && *(st + (i + m)) != '\n'){
                if(*(st + i) == '-')
                    neg = 1;
                else if(*(st + (i + m)) < '0' || *(st + (i + m)) > '9')
                        only_num = 0;
                m++;
            }
            if(only_num == 1){
                int num = 0;
                for(int z = 0; z < m; z++){
                    if(neg == 1);
                    else
                        num = num * 10 + (*(st + (i + z)) - '0')
                }
                if(neg == 1)
                    num = -num;
                char temp_bin[12];
                make_binary(num, line, temp_bin);
                for(int z = 0; z < 12; z++){
                    if(z > 9)
                        temp_bin[z] = '0';
                    else
                        temp_bin[z] = temp_bin[z + 2];
                }
                first_binary_word = temp_bin;
            }
            else if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                Data_Table temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    first_binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                first_binary_word = temp_bin;
            }
            
            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) == '\n'){
                printf("Error in line %d: only one operand in a two operand function");
                ERRORS++;
                return 0;
            }

            l = 0, m = 0, only_num = 1, neg = 0;
            while(*(st + (i + m)) != '\t' && *(st + (i + m)) != ' ' && *(st + (i + m)) != '\n'){
                if(*(st + i) == '-')
                    neg = 1;
                else if(*(st + (i + m)) < '0' || *(st + (i + m)) > '9')
                        only_num = 0;
                m++;
            }
            if(only_num == 1){
                int num = 0;
                for(int z = 0; z < m; z++){
                    if(neg == 1);
                    else
                        num = num * 10 + (*(st + (i + z)) - '0')
                }
                if(neg == 1)
                    num = -num;
                char temp_bin[12];
                make_binary(num, line, temp_bin);
                for(int z = 0; z < 12; z++){
                    if(z > 9)
                        temp_bin[z] = '0';
                    else
                        temp_bin[z] = temp_bin[z + 2];
                }
                second_binary_word = temp_bin;
            }
            else if(*(st + i) != '@' || *(st + (i + 1)) != 'r' || *(st + (i + 2)) > '7' ||  *(st + (i + 2)) < '0'){ //check if operand is not a legal register
                while(*(st + i) != ' ' && *(st + i) != '\t' && *(st + i) != '\n')
                    l++;
                int in = 0, j = 0;
                Data_Table temp = data_head;
                while(j < counter && in != 1){
                    if(strncmp(temp.data, st + sizeof(char) * i, l) == 0)
                        in = 1;
                    else{
                        temp = get_next(temp);
                        j++;
                    }
                }
                if(in != 1){
                    ERRORS++;
                    errors_here++;
                    printf("Error in line %d: reference to an undeclared label")
                }
                else{
                    char temp_bin[12];
                    make_binary(temp.value, line, temp_bin);
                    for(int k = 0; k < 10; k++)
                        temp_bin[k] = temp_bin[k + 2];
                    char ARE[] = temp.type == 'x' ? "01" : "10";
                    for(int k = 10; k < 12; k++)
                        temp_bin[k] = ARE[k - 10];
                    second_binary_word = temp_bin;

                }
            }
            else{
                char temp_bin[12];
                make_binary(*(st + (i + 2)) - '0', line, temp_bin);
                int k = 0;
                for(; k < 5; k++)
                    temp_bin[k] = temp_bin[k + 7];
                for(; k < 12; k++)
                    temp_bin[k] = '0';
                second_binary_word = temp_bin;
            }

            SKIP_NON_WHITE(st, i);
            SKIP_WHITE(st, i);
            if(*(st + i) != '\n'){//if there are chars that arent white after the word
                printf("Error in line %d: more then two operands in a two operand function");//wrong syntax
                ERRORS++;
                errors_here++;
            }
            if(errors_here > 0)
                return 0;
            curr_node->binary[0] = make_command_binary(st);
            curr_node->binary[1] = first_binary_word;
            curr_node-binary[2] = second_binary_word;
            return 1;
        }

        return 2;  
}
